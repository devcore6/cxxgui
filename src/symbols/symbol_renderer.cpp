#include <cxxgui/cxxgui.hpp>
#include <iostream>
namespace cxxgui {

    float symbol::get_content_width() {
        float rendered_width = 64.0f;

        if(style.width != 0.0f) width = style.width;
        if(rendered_width < style.min_width) rendered_width = style.min_width;
        if(style.max_width != 0.0f && rendered_width > style.max_width)
            rendered_width = style.max_width;

        return rendered_width;
    }

    float symbol::get_content_height() {
        float rendered_height = 64.0f;

        if(style.height != 0.0f) height = style.height;
        if(rendered_height < style.min_height) rendered_height = style.min_height;
        if(style.max_height != 0.0f && rendered_height > style.max_height)
            rendered_height = style.max_height;

        return rendered_height;
    }

    void symbol::render() {
        if(texture_id == 0) {
            if(render_mode == symbol_rendering_modes::monochrome) {
                color2 = color1;
                color3 = color1;
                color4 = color1;
            }

            /*
             * Warning: jank alert
             * Weak minds look away
             */

            size_t pos = std::string::npos;

            while((pos = svg_data.find("rgb(0,0,0)")) != std::string::npos) {
                svg_data.erase(pos, 10);
                svg_data.insert(
                    pos,
                    std::string("rgba(") +
                    std::to_string((color1 >> 24) & 0xFF) +
                    ',' +
                    std::to_string((color1 >> 16) & 0xFF) +
                    ',' +
                    std::to_string((color1 >> 8) & 0xFF) +
                    ',' +
                    std::to_string(color1 & 0xFF) +
                    ')'
                );
            }

            while((pos = svg_data.find("rgb(64,64,64)")) != std::string::npos) {
                svg_data.erase(pos, 13);
                svg_data.insert(
                    pos,
                    std::string("rgba(") +
                    std::to_string((color2 >> 24) & 0xFF) +
                    ',' +
                    std::to_string((color2 >> 16) & 0xFF) +
                    ',' +
                    std::to_string((color2 >> 8) & 0xFF) +
                    ',' +
                    std::to_string(color2 & 0xFF) +
                    ')'
                );
            }

            while((pos = svg_data.find("rgb(128,128,128)")) != std::string::npos) {
                svg_data.erase(pos, 16);
                svg_data.insert(
                    pos,
                    std::string("rgba(") +
                    std::to_string((color3 >> 24) & 0xFF) +
                    ',' +
                    std::to_string((color3 >> 16) & 0xFF) +
                    ',' +
                    std::to_string((color3 >> 8) & 0xFF) +
                    ',' +
                    std::to_string(color3 & 0xFF) +
                    ')'
                );
            }

            while((pos = svg_data.find("rgb(192,192,192)")) != std::string::npos) {
                svg_data.erase(pos, 16);
                svg_data.insert(
                    pos,
                    std::string("rgba(") +
                    std::to_string((color4 >> 24) & 0xFF) +
                    ',' +
                    std::to_string((color4 >> 16) & 0xFF) +
                    ',' +
                    std::to_string((color4 >> 8) & 0xFF) +
                    ',' +
                    std::to_string(color4 & 0xFF) +
                    ')'
                );
            }

            // Note:
            // This doesn't work. SDL_Image can't render SVGs properly.
            // The colors are all messed up, and it's not my jank from above
            // that's messing them up, I know that because I have tried
            // disabling it and they're still all messed up, I have also
            // just tried rendering the output generated by that janky mess
            // on Chrome, and Chrome displayed it fine, ergo it must be
            // SDL_Image.
            // 
            // I will fix it in the next commit by switching to another
            // libraries to render SVGs, even though I really do not want
            // to keep adding more and more libaries...

            SDL_RWops* mem = SDL_RWFromConstMem(svg_data.data(), svg_data.capacity());
            if(!mem) return;

            SDL_Surface* surface = IMG_LoadSVG_RW(mem);

            SDL_RWclose(mem);
            if(!surface) return;

            int mode = GL_RGB;
            if(surface->format->BytesPerPixel == 4) {
                if(surface->format->Rmask == 0x000000ff)
                    mode = GL_RGBA;
                else
                    mode = GL_BGRA;
            } else {
                if(surface->format->Rmask == 0x000000ff)
                    mode = GL_RGB;
                else
                    mode = GL_BGR;
            }

            glGenTextures(1, &texture_id);
            glBindTexture(GL_TEXTURE_2D, texture_id);

            glTexImage2D(GL_TEXTURE_2D, 0, surface->format->BytesPerPixel, surface->w, surface->h, 0, mode, GL_UNSIGNED_BYTE, surface->pixels);

            glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

            glBindTexture(GL_TEXTURE_2D, 0);

            width = (float)surface->w;
            height = (float)surface->h;

            SDL_FreeSurface(surface);
        }

        if(texture_id != 0) {
            glPushMatrix();

                glTranslatef(style.offset_x + style.margin_left,
                             style.offset_y + style.margin_top,
                             0.0f);
                glRotatef(style.rotation, 0.0f, 0.0f, 1.0f);

                float w = get_content_box_width();
                float h = get_content_box_height();

                render_background();
                glPushMatrix();

                    glTranslatef(style.border_left.stroke + style.padding_left,
                                 style.border_top.stroke + style.padding_top,
                                 0.0f);


                    float rendered_width  = get_content_width();
                    float rendered_height = get_content_height();

                    glEnable(GL_TEXTURE_2D);
                    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
                    glBindTexture(GL_TEXTURE_2D, texture_id);

                    // why is this scaling needed???

                    glBegin(GL_QUADS);

                        glTexCoord2f(0.0f, 0.0f);
                        glVertex2f(0.0f, 0.0f);

                        glTexCoord2f(1.0f, 0.0f);
                        glVertex2f(rendered_width * 1.3334f, 0.0f);

                        glTexCoord2f(1.0f, 1.0f);
                        glVertex2f(rendered_width * 1.3334f, rendered_height * 1.3334f);

                        glTexCoord2f(0.0f, 1.0f);
                        glVertex2f(0.0f, rendered_height * 1.3334f);

                    glEnd();

                    glBindTexture(GL_TEXTURE_2D, 0);

                    glDisable(GL_TEXTURE_2D);

                glPopMatrix();

                render_borders();

            glPopMatrix();

        }
    }

}
